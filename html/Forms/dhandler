<&|/FormTools/Form, next => $base_path . $form_name . '/' . $form_config->{'formtools-pages'}{$page}{'next'},
    validation => $form_config->{'formtools-pages'}{$page}{'validation'},
    next_for_validation => $base_path . $form_name . '/' . $page,
    results_ref => \@results,
    self_service => $SelfService,
    include_tabs => 1,
    form_config => $form_config,
&>

<%perl>
# Build the current page here dyamically from config

my $button_label = loc('Next');
foreach my $element ( @{$form_config->{'formtools-pages'}{$page}{'content'}} ) {
    if ( $element->{type} eq 'raw_html' ) {
        $m->out( $element->{html} );
    }
    elsif ( $element->{type} eq 'hidden' ) {
        $m->out('<input type="hidden" class="hidden" name="' . $element->{'input-name'}
            . '" value="' . $element->{'input-value'} . '"  />');
    }
    elsif ( $element->{type} eq 'component' ) {
        $m->comp('/FormTools/' . $element->{comp_name}, %{$element->{arguments}});
    }

    if ( $element->{type} eq 'hidden'
         and $element->{'input-name'} eq 'create_ticket' ) {

        # This is the page that will submit, so change the button label
        $button_label = loc('Submit');
    }
}
</%perl>

% if ( $form_config->{'formtools-pages'}{$page}{'next'} ) {
 <& /FormTools/Next, Label => $button_label, Back => $show_back &>
% }
</&>
<%init>

my $path = $m->dhandler_arg;
my ($form_name, $page_name);

if ( $path =~ /^([\w\s]+)\/([-\w]+)$/ ) {
    $form_name = $1;
    $page_name = $2;
}
else {
    $form_name = $path;
}

# Limit to names to letters, numbers, underscore, spaces
unless ( $form_name =~ /^[\w\s]+$/ ) {
    RT->Logger->error("FormTools called with invalid form name: $form_name");
    Abort('Invalid form name');
}

if ( $page_name ) {
    unless ( $page_name =~ /^[-\w]+$/ ) {
        RT->Logger->error("FormTools called with invalid page name: $page_name");
        Abort('Invalid page name');
    }
}

# Load FormTools configration and look for a configured
# form with the provided name.
my $form_attribute = RT::Attribute->new( $session{CurrentUser} );
$form_attribute->LoadByCols( Name => 'FormTools Form', Description => $form_name );
my $form_config;

if ( $form_attribute->Id ) {
    Abort( loc("Permission Denied") ) unless $form_attribute->CurrentUserCanSee;
    $form_config = $form_attribute->Content;
}
else {
    # We didn't find a form, so show a not found page
    Abort('Form not found');
}

my $page;

if ( $page_name ) {
    $page = $page_name;
}
else {
    $page = $form_config->{'formtools-start-page'};
}

my $queue_obj = RT::Queue->new( RT->SystemUser );
my ($ok, $msg) = $queue_obj->Load( $form_config->{'queue'} );

unless ( $ok ) {
    RT->Logger->error('FormTools unable to load queue: ' . $form_config->{'queue'});
    Abort('Unable to load form, invalid queue');
}

$m->notes( queue => $queue_obj );
$m->notes( page_title => $form_config->{'formtools-pages'}{$page}{'name'} );

my $base_path = '/Forms/';
$base_path = '/SelfService' . $base_path if $SelfService;

my $validation = $form_config->{'formtools-pages'}{$page}{'validation'};

if ( $validation and not $ARGS{'validation_ok'} ) {
    # If validation is enabled and it didn't pass, don't create
    $create_ticket = 0;
}

my @form_pages
    = sort { ( $form_config->{'formtools-pages'}{$a}{sort_order} || 0 ) <=> ( $form_config->{'formtools-pages'}{$b}{sort_order} || 0 ) }
    keys %{ $form_config->{'formtools-pages'} };

my $show_back = 0;
my $index = 0;
my $back_page;

# When validation is enabled for this page, it submits to itself
# first, so the back button only needs to go back 1. Otherwise,
# current page was "next" on submit, so we need to go back 2.
my $go_back_count = $validation ? 1 : 2;

foreach my $page_index ( @form_pages ) {
    if ( $page_index eq $page ) {
        $back_page = $form_pages[$index - $go_back_count];
        last;
    }
    $index++;
}

# Don't show the back button on the first page
$show_back = 1 if $index > 0;

# Did the user click Back?
if ( $ARGS{Back} and $ARGS{Back} eq 'Back' ) {
    # Avoid trying to go back again
    delete $ARGS{Back};

    # Don't create a ticket when going back
    delete $ARGS{'create_ticket'} if $ARGS{'create_ticket'};
    $create_ticket = 0;

    $_form_tools_next = '';
    delete $ARGS{'_form_tools_next'} if $ARGS{'_form_tools_next'};

    for my $field ( grep { /Object-RT::Ticket--CustomField-/ } keys %ARGS ) {
        next if length $ARGS{$field};
        delete $ARGS{$field};
        delete $ARGS{"$field-Magic"};
    }

    # Redirect to the previous page
    MaybeRedirectForResults(
        Path      => $base_path . $form_name . '/' . $back_page,
        Arguments => \%ARGS,
        Force     => 1,
    );
}

# Try to create a ticket if we're on the last page and
# "create_ticket" is submitted as an arg from the second-to-last
# page.

my ($ticket_obj, @results);
if ( $create_ticket ) {

    $m->callback( CallbackName => 'BeforeCreate', ARGSRef => \%ARGS, results => \@results,
                  FormName => $form_name, PageName => $page );

    # We override Abort elsewhere so we'll get $ticket_obj here even if
    # the current user has no rights to see the newly created ticket.

    # We deliberately don't pass along @results because the work
    # behind the scenes is "magic" and we don't want the form user to
    # see any details, like ticket ids or queues, if they are not supposed
    # to see them.

    ($ticket_obj) = CreateTicket(
        Subject => 'Ticket created from FormTools form ' . $form_name,
        Queue   => $queue_obj->Id,
        Status => 'new',
        Requestors => $session{'CurrentUser'}->EmailAddress,
        %ARGS,
    );
}

</%init>
<%args>
$_form_tools_next => undef
$create_ticket => undef
$SelfService => 0
</%args>
